<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Ref&lt; TType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_ref-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ref&lt; TType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents the basic strong reference to any <a class="el" href="class_object.html" title="Represents the basic object class that allows for creating managed objects in the program.">Object</a>. This reference will block the object from being destroyed.  
 <a href="class_ref.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_ref_8h_source.html">Ref.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a73f8a459509492ff5281240d2eefb2d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#a73f8a459509492ff5281240d2eefb2d5">Ref</a> ()</td></tr>
<tr class="memdesc:a73f8a459509492ff5281240d2eefb2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty reference.  <a href="#a73f8a459509492ff5281240d2eefb2d5">More...</a><br /></td></tr>
<tr class="separator:a73f8a459509492ff5281240d2eefb2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a02585d57ba2d0fd2066372ed422c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#a51a02585d57ba2d0fd2066372ed422c8">~Ref</a> ()</td></tr>
<tr class="memdesc:a51a02585d57ba2d0fd2066372ed422c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the reference.  <a href="#a51a02585d57ba2d0fd2066372ed422c8">More...</a><br /></td></tr>
<tr class="separator:a51a02585d57ba2d0fd2066372ed422c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235b1cec9594a29c7d4c6b58e92bc602"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#a235b1cec9594a29c7d4c6b58e92bc602">Ref</a> (T *ptr)</td></tr>
<tr class="memdesc:a235b1cec9594a29c7d4c6b58e92bc602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an reference to the object pointer. Takes the authority of the specified pointer which means after creation the pointer must no longer be used for other operations. Used to easly create references to object from new keyword.  <a href="#a235b1cec9594a29c7d4c6b58e92bc602">More...</a><br /></td></tr>
<tr class="separator:a235b1cec9594a29c7d4c6b58e92bc602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2c482df7f5bc1b71cf36e962f0fd0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#ace2c482df7f5bc1b71cf36e962f0fd0a">Ref</a> (const std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ace2c482df7f5bc1b71cf36e962f0fd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reference from the shared_ptr. Allows to convert shared_ptr to references. Used mainly in convienient conversions from shared_ptr.  <a href="#ace2c482df7f5bc1b71cf36e962f0fd0a">More...</a><br /></td></tr>
<tr class="separator:ace2c482df7f5bc1b71cf36e962f0fd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a5311e5afb91b98e20c5d96c3ae31b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#af5a5311e5afb91b98e20c5d96c3ae31b">Ref</a> (const <a class="el" href="class_ref.html">Ref</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:af5a5311e5afb91b98e20c5d96c3ae31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reference by copying the value from the other reference.  <a href="#af5a5311e5afb91b98e20c5d96c3ae31b">More...</a><br /></td></tr>
<tr class="separator:af5a5311e5afb91b98e20c5d96c3ae31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff7c9e8c09bd700086040b8b6f89a35"><td class="memTemplParams" colspan="2">template&lt;typename  = std::enable_if&lt;std::is_const&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a0ff7c9e8c09bd700086040b8b6f89a35"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ref.html#a0ff7c9e8c09bd700086040b8b6f89a35">Ref</a> (const <a class="el" href="class_ref.html">Ref</a>&lt; std::remove_const_t&lt; T &gt;&gt; &amp;other)</td></tr>
<tr class="memdesc:a0ff7c9e8c09bd700086040b8b6f89a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for converting <a class="el" href="class_ref.html" title="Represents the basic strong reference to any Object. This reference will block the object from being ...">Ref</a>&lt;T&gt; to <a class="el" href="class_ref.html" title="Represents the basic strong reference to any Object. This reference will block the object from being ...">Ref</a>&lt;const T&gt; implicitly. Only enabled if current class contains const T type parameter.  <a href="#a0ff7c9e8c09bd700086040b8b6f89a35">More...</a><br /></td></tr>
<tr class="separator:a0ff7c9e8c09bd700086040b8b6f89a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56886343e7faf21e18bec16042535cf5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#a56886343e7faf21e18bec16042535cf5">Ref</a> (const <a class="el" href="class_ref.html">Ref</a>&lt; T &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a56886343e7faf21e18bec16042535cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for moving the reference. Makes returning refernces creating less copies of the shared pointers.  <a href="#a56886343e7faf21e18bec16042535cf5">More...</a><br /></td></tr>
<tr class="separator:a56886343e7faf21e18bec16042535cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf07d54c8951e7f026faef51950c18a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ref.html">Ref</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#aaf07d54c8951e7f026faef51950c18a6">operator=</a> (const <a class="el" href="class_ref.html">Ref</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:aaf07d54c8951e7f026faef51950c18a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for copying the reference using the assign operator.  <a href="#aaf07d54c8951e7f026faef51950c18a6">More...</a><br /></td></tr>
<tr class="separator:aaf07d54c8951e7f026faef51950c18a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8746320aa81f63d923172305b8d173"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#a8a8746320aa81f63d923172305b8d173">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a8a8746320aa81f63d923172305b8d173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for fast access to the T object members.  <a href="#a8a8746320aa81f63d923172305b8d173">More...</a><br /></td></tr>
<tr class="separator:a8a8746320aa81f63d923172305b8d173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8b77f0e2128c4c373909703e14df5d"><td class="memTemplParams" colspan="2">template&lt;typename  = std::enable_if_t&lt;std::negation&lt;std::is_same&lt;T, Object&gt;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aab8b77f0e2128c4c373909703e14df5d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ref.html#aab8b77f0e2128c4c373909703e14df5d">operator==</a> (const <a class="el" href="class_ref.html">Ref</a>&lt; const T &gt; &amp;right) const</td></tr>
<tr class="memdesc:aab8b77f0e2128c4c373909703e14df5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares current reference to other const one. Enabled only if compared reference is not reference to object.  <a href="#aab8b77f0e2128c4c373909703e14df5d">More...</a><br /></td></tr>
<tr class="separator:aab8b77f0e2128c4c373909703e14df5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a33c7a0fb318d86cbe5bf5ec206bd5"><td class="memTemplParams" colspan="2">template&lt;typename  = std::enable_if_t&lt;std::negation&lt;std::is_const&lt;T&gt;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a27a33c7a0fb318d86cbe5bf5ec206bd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ref.html#a27a33c7a0fb318d86cbe5bf5ec206bd5">operator==</a> (const <a class="el" href="class_ref.html">Ref</a>&lt; std::remove_const_t&lt; T &gt;&gt; &amp;right) const</td></tr>
<tr class="memdesc:a27a33c7a0fb318d86cbe5bf5ec206bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares current reference to other non const reference. Enabled only if compared reference is not const reference.  <a href="#a27a33c7a0fb318d86cbe5bf5ec206bd5">More...</a><br /></td></tr>
<tr class="separator:a27a33c7a0fb318d86cbe5bf5ec206bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33d6085174ef867bb4cea065a432ff5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#ac33d6085174ef867bb4cea065a432ff5">operator==</a> (const T *right) const</td></tr>
<tr class="memdesc:ac33d6085174ef867bb4cea065a432ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cehcks if the current reference is referencing the same object as the specified pointer.  <a href="#ac33d6085174ef867bb4cea065a432ff5">More...</a><br /></td></tr>
<tr class="separator:ac33d6085174ef867bb4cea065a432ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8970ca9149b48f6c77527f38c2a5e054"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#a8970ca9149b48f6c77527f38c2a5e054">operator!=</a> (const T *right) const</td></tr>
<tr class="memdesc:a8970ca9149b48f6c77527f38c2a5e054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cehcks if the current reference is not referencing the same object as the specified pointer.  <a href="#a8970ca9149b48f6c77527f38c2a5e054">More...</a><br /></td></tr>
<tr class="separator:a8970ca9149b48f6c77527f38c2a5e054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed42f0368b0f72de67c391a731392154"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#aed42f0368b0f72de67c391a731392154">operator!</a> () const</td></tr>
<tr class="memdesc:aed42f0368b0f72de67c391a731392154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if current reference is an empty one.  <a href="#aed42f0368b0f72de67c391a731392154">More...</a><br /></td></tr>
<tr class="separator:aed42f0368b0f72de67c391a731392154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bedcfebf713236ee66a5c1e06cbfec"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename  = std::enable_if_t&lt;(std::is_assignable&lt;T2&amp;, T&amp;&gt;::value || std::is_assignable&lt;T&amp;, T2&amp;&gt;::value)&gt;&gt; </td></tr>
<tr class="memitem:a74bedcfebf713236ee66a5c1e06cbfec"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ref.html#a74bedcfebf713236ee66a5c1e06cbfec">operator Ref&lt; T2 &gt;</a> () const</td></tr>
<tr class="memdesc:a74bedcfebf713236ee66a5c1e06cbfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for explicit casting from the one reference to another. Enabled only if the type to which the reference is casted is assignable from current type and vice versa.  <a href="#a74bedcfebf713236ee66a5c1e06cbfec">More...</a><br /></td></tr>
<tr class="separator:a74bedcfebf713236ee66a5c1e06cbfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092daaa0d297f615642fc4870cff4f47"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename  = std::enable_if_t&lt;std::is_assignable&lt;T2&amp;, T&amp;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a092daaa0d297f615642fc4870cff4f47"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ref.html#a092daaa0d297f615642fc4870cff4f47">operator Ref&lt; T2 &gt;</a> ()</td></tr>
<tr class="memdesc:a092daaa0d297f615642fc4870cff4f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for implicit casting from the one reference to another. Enabled only if the type to which the reference is casted is assignable from current type.  <a href="#a092daaa0d297f615642fc4870cff4f47">More...</a><br /></td></tr>
<tr class="separator:a092daaa0d297f615642fc4870cff4f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1feffacefd6a3f6e42a362e0669264ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#a1feffacefd6a3f6e42a362e0669264ee">operator bool</a> () const</td></tr>
<tr class="memdesc:a1feffacefd6a3f6e42a362e0669264ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if current reference is not an empty one.  <a href="#a1feffacefd6a3f6e42a362e0669264ee">More...</a><br /></td></tr>
<tr class="separator:a1feffacefd6a3f6e42a362e0669264ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3debb396d13901075faf5bd1663ae9c6"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a3debb396d13901075faf5bd1663ae9c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_ref.html">Ref</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ref.html#a3debb396d13901075faf5bd1663ae9c6">as</a> () const</td></tr>
<tr class="memdesc:a3debb396d13901075faf5bd1663ae9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamic cast to the specified type. If current refernce is not assignable to the specified type then empty reference is returned.  <a href="#a3debb396d13901075faf5bd1663ae9c6">More...</a><br /></td></tr>
<tr class="separator:a3debb396d13901075faf5bd1663ae9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616580cb90ccb7611dcc3b2c1d15130d"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename  = std::enable_if_t&lt;(std::is_assignable&lt;T2&amp;, T&amp;&gt;::value || std::is_assignable&lt;T&amp;, T2&amp;&gt;::value)&gt;&gt; </td></tr>
<tr class="memitem:a616580cb90ccb7611dcc3b2c1d15130d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_ref.html">Ref</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ref.html#a616580cb90ccb7611dcc3b2c1d15130d">cast</a> () const</td></tr>
<tr class="memdesc:a616580cb90ccb7611dcc3b2c1d15130d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static cast to the specified type. Enabled only if the type to which the reference is casted is assignable from current type and vice versa.  <a href="#a616580cb90ccb7611dcc3b2c1d15130d">More...</a><br /></td></tr>
<tr class="separator:a616580cb90ccb7611dcc3b2c1d15130d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1c08e3689380efc4471e109dafce28"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a1f1c08e3689380efc4471e109dafce28"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ref.html#a1f1c08e3689380efc4471e109dafce28">is</a> () const</td></tr>
<tr class="memdesc:a1f1c08e3689380efc4471e109dafce28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamic type check. If current refernce is not assignable to the specified type then false is returned.  <a href="#a1f1c08e3689380efc4471e109dafce28">More...</a><br /></td></tr>
<tr class="separator:a1f1c08e3689380efc4471e109dafce28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44580a655b72ebbae930b3056f85277"><td class="memTemplParams" colspan="2">template&lt;typename  = std::enable_if_t&lt;std::is_array_v&lt;TType&gt;&gt;&gt; </td></tr>
<tr class="memitem:af44580a655b72ebbae930b3056f85277"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ref.html#af44580a655b72ebbae930b3056f85277">operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:af44580a655b72ebbae930b3056f85277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for easy access to the array elements when TType is an array.  <a href="#af44580a655b72ebbae930b3056f85277">More...</a><br /></td></tr>
<tr class="separator:af44580a655b72ebbae930b3056f85277"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0dff788348708e8d176d3154d15f4e3a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ref.html#a0dff788348708e8d176d3154d15f4e3a">referenceEquals</a> (const <a class="el" href="class_ref.html">Ref</a>&lt; const T &gt; &amp;first, const <a class="el" href="class_ref.html">Ref</a>&lt; const T &gt; &amp;second)</td></tr>
<tr class="memdesc:a0dff788348708e8d176d3154d15f4e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two references of the same types are equal.  <a href="#a0dff788348708e8d176d3154d15f4e3a">More...</a><br /></td></tr>
<tr class="separator:a0dff788348708e8d176d3154d15f4e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a872a328b30cc36b030fb5830488fe2e5"><td class="memItemLeft" align="right" valign="top"><a id="a872a328b30cc36b030fb5830488fe2e5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Ref&lt; std::remove_const_t&lt; T &gt; &gt;</b></td></tr>
<tr class="separator:a872a328b30cc36b030fb5830488fe2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643f2206cd45ca251329b8cd0a229661"><td class="memItemLeft" align="right" valign="top"><a id="a643f2206cd45ca251329b8cd0a229661"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Ref&lt; std::add_const_t&lt; T &gt; &gt;</b></td></tr>
<tr class="separator:a643f2206cd45ca251329b8cd0a229661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dafcb9b25b84e93a71f6792a5192bd"><td class="memItemLeft" align="right" valign="top"><a id="a41dafcb9b25b84e93a71f6792a5192bd"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>WeakRef&lt; T &gt;</b></td></tr>
<tr class="separator:a41dafcb9b25b84e93a71f6792a5192bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TType&gt;<br />
class Ref&lt; TType &gt;</h3>

<p>Represents the basic strong reference to any <a class="el" href="class_object.html" title="Represents the basic object class that allows for creating managed objects in the program.">Object</a>. This reference will block the object from being destroyed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a73f8a459509492ff5281240d2eefb2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f8a459509492ff5281240d2eefb2d5">&#9670;&nbsp;</a></span>Ref() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::<a class="el" href="class_ref.html">Ref</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty reference. </p>

</div>
</div>
<a id="a51a02585d57ba2d0fd2066372ed422c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a02585d57ba2d0fd2066372ed422c8">&#9670;&nbsp;</a></span>~Ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::~<a class="el" href="class_ref.html">Ref</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the reference. </p>

</div>
</div>
<a id="a235b1cec9594a29c7d4c6b58e92bc602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235b1cec9594a29c7d4c6b58e92bc602">&#9670;&nbsp;</a></span>Ref() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::<a class="el" href="class_ref.html">Ref</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an reference to the object pointer. Takes the authority of the specified pointer which means after creation the pointer must no longer be used for other operations. Used to easly create references to object from new keyword. </p>

</div>
</div>
<a id="ace2c482df7f5bc1b71cf36e962f0fd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2c482df7f5bc1b71cf36e962f0fd0a">&#9670;&nbsp;</a></span>Ref() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::<a class="el" href="class_ref.html">Ref</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a reference from the shared_ptr. Allows to convert shared_ptr to references. Used mainly in convienient conversions from shared_ptr. </p>

</div>
</div>
<a id="af5a5311e5afb91b98e20c5d96c3ae31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a5311e5afb91b98e20c5d96c3ae31b">&#9670;&nbsp;</a></span>Ref() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::<a class="el" href="class_ref.html">Ref</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ref.html">Ref</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a reference by copying the value from the other reference. </p>

</div>
</div>
<a id="a0ff7c9e8c09bd700086040b8b6f89a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff7c9e8c09bd700086040b8b6f89a35">&#9670;&nbsp;</a></span>Ref() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<div class="memtemplate">
template&lt;typename  = std::enable_if&lt;std::is_const&lt;T&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::<a class="el" href="class_ref.html">Ref</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ref.html">Ref</a>&lt; std::remove_const_t&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows for converting <a class="el" href="class_ref.html" title="Represents the basic strong reference to any Object. This reference will block the object from being ...">Ref</a>&lt;T&gt; to <a class="el" href="class_ref.html" title="Represents the basic strong reference to any Object. This reference will block the object from being ...">Ref</a>&lt;const T&gt; implicitly. Only enabled if current class contains const T type parameter. </p>

</div>
</div>
<a id="a56886343e7faf21e18bec16042535cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56886343e7faf21e18bec16042535cf5">&#9670;&nbsp;</a></span>Ref() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::<a class="el" href="class_ref.html">Ref</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ref.html">Ref</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows for moving the reference. Makes returning refernces creating less copies of the shared pointers. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3debb396d13901075faf5bd1663ae9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3debb396d13901075faf5bd1663ae9c6">&#9670;&nbsp;</a></span>as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt;T2&gt; <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::as </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs dynamic cast to the specified type. If current refernce is not assignable to the specified type then empty reference is returned. </p>

</div>
</div>
<a id="a616580cb90ccb7611dcc3b2c1d15130d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616580cb90ccb7611dcc3b2c1d15130d">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename  = std::enable_if_t&lt;(std::is_assignable&lt;T2&amp;, T&amp;&gt;::value || std::is_assignable&lt;T&amp;, T2&amp;&gt;::value)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt;T2&gt; <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs static cast to the specified type. Enabled only if the type to which the reference is casted is assignable from current type and vice versa. </p>

</div>
</div>
<a id="a1f1c08e3689380efc4471e109dafce28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1c08e3689380efc4471e109dafce28">&#9670;&nbsp;</a></span>is()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::is </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs dynamic type check. If current refernce is not assignable to the specified type then false is returned. </p>

</div>
</div>
<a id="a1feffacefd6a3f6e42a362e0669264ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1feffacefd6a3f6e42a362e0669264ee">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if current reference is not an empty one. </p>

</div>
</div>
<a id="a74bedcfebf713236ee66a5c1e06cbfec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bedcfebf713236ee66a5c1e06cbfec">&#9670;&nbsp;</a></span>operator Ref&lt; T2 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename  = std::enable_if_t&lt;(std::is_assignable&lt;T2&amp;, T&amp;&gt;::value || std::is_assignable&lt;T&amp;, T2&amp;&gt;::value)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::operator <a class="el" href="class_ref.html">Ref</a>&lt; T2 &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows for explicit casting from the one reference to another. Enabled only if the type to which the reference is casted is assignable from current type and vice versa. </p>

</div>
</div>
<a id="a092daaa0d297f615642fc4870cff4f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092daaa0d297f615642fc4870cff4f47">&#9670;&nbsp;</a></span>operator Ref&lt; T2 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename  = std::enable_if_t&lt;std::is_assignable&lt;T2&amp;, T&amp;&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::operator <a class="el" href="class_ref.html">Ref</a>&lt; T2 &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows for implicit casting from the one reference to another. Enabled only if the type to which the reference is casted is assignable from current type. </p>

</div>
</div>
<a id="aed42f0368b0f72de67c391a731392154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed42f0368b0f72de67c391a731392154">&#9670;&nbsp;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if current reference is an empty one. </p>

</div>
</div>
<a id="a8970ca9149b48f6c77527f38c2a5e054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8970ca9149b48f6c77527f38c2a5e054">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::<a class="el" href="class_ref.html#aed42f0368b0f72de67c391a731392154">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cehcks if the current reference is not referencing the same object as the specified pointer. </p>

</div>
</div>
<a id="a8a8746320aa81f63d923172305b8d173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8746320aa81f63d923172305b8d173">&#9670;&nbsp;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows for fast access to the T object members. </p>

</div>
</div>
<a id="aaf07d54c8951e7f026faef51950c18a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf07d54c8951e7f026faef51950c18a6">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ref.html">Ref</a>&lt;T&gt;&amp; <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ref.html">Ref</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows for copying the reference using the assign operator. </p>

</div>
</div>
<a id="aab8b77f0e2128c4c373909703e14df5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8b77f0e2128c4c373909703e14df5d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<div class="memtemplate">
template&lt;typename  = std::enable_if_t&lt;std::negation&lt;std::is_same&lt;T, Object&gt;&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ref.html">Ref</a>&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares current reference to other const one. Enabled only if compared reference is not reference to object. </p>

</div>
</div>
<a id="a27a33c7a0fb318d86cbe5bf5ec206bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a33c7a0fb318d86cbe5bf5ec206bd5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<div class="memtemplate">
template&lt;typename  = std::enable_if_t&lt;std::negation&lt;std::is_const&lt;T&gt;&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ref.html">Ref</a>&lt; std::remove_const_t&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares current reference to other non const reference. Enabled only if compared reference is not const reference. </p>

</div>
</div>
<a id="ac33d6085174ef867bb4cea065a432ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33d6085174ef867bb4cea065a432ff5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cehcks if the current reference is referencing the same object as the specified pointer. </p>

</div>
</div>
<a id="af44580a655b72ebbae930b3056f85277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44580a655b72ebbae930b3056f85277">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<div class="memtemplate">
template&lt;typename  = std::enable_if_t&lt;std::is_array_v&lt;TType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows for easy access to the array elements when TType is an array. </p>

</div>
</div>
<a id="a0dff788348708e8d176d3154d15f4e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dff788348708e8d176d3154d15f4e3a">&#9670;&nbsp;</a></span>referenceEquals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_ref.html">Ref</a>&lt; TType &gt;::referenceEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ref.html">Ref</a>&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ref.html">Ref</a>&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two references of the same types are equal. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ref_8h_source.html">Ref.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
